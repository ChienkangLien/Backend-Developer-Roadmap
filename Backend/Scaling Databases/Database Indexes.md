# Database Indexes
索引其實是一種資料結構（data structure），我們看不到，因為它通常存在我們使用的資料庫管理系統（DBSM, Database Management System）裡面。

## 運作方式
大部分的 DBSM 都會預設把主鍵（Primary Key / ID）加上索引，現在假設有一個資料表（table）A，A 的 ID 欄位有被加上索引，則實際上在資料庫中，有另外一張表（我們叫它 A’）裡面儲存了 A 裡面的所有 ID，而 A’ 每一個資料（ID）都對應到 A 中的完整資料。

所以今天我們想要找 A 中一個 ID = 3 的資料，資料庫會用 Binary Search Algorithm（或是其他的演算法）在 A’ 中快速找到 ID = 3 這筆資料，然後再從這筆資料連到 A 中對應的資料。

實際情況下，A’ 這個擁有 A 的 ID 資料的儲存結構通常會以 Hash 或是 B-tree 實作。Hash 在搜尋不能重複的資料時，效率會比較好，因此適合用在主索引鍵（Primary Index）和唯一索引（Unique Index）；B-tree 適合用在可以允許重複資料的一般索引（Non-Unique Index）。
## 使用上的限制
索引之所以可以增加資料庫的效率，是因為它額外創造了一張表來儲存索引的資料，也就是拿空間換取時間。對資料庫做的任何更動也都會連動到索引表（Index Table），如果這是一張更動很頻繁的表，那就會製造額外的負擔。

```sql=
SELECT first_name FROM people WHERE last_name = 'Shih';
```
如果 last_name 欄位沒有被索引，那麼就會是一個 full table scan。如果有索引，那資料庫系統就會使用 B-tree 結構來尋找。
```sql=
SELECT full_name FROM people WHERE full_name LIKE '%Shih';
```
就算full_name 有索引，還是會引發 full table scan，因為索引的預設搜尋方向是從左到右，當搜尋的字串開頭是通配符（wildcard），資料庫系統就沒有辦法使用 B-tree 了。

要解決這個困境可以增加一個 reverse(full_name) 的索引，然後改變 SQL 查詢：
```sql=
SELECT full_name FROM people WHERE reverse(full_name) LIKE reverse('Shih');
```

## 常見類型的索引
* 主鍵索引（Primary Key Index）： 唯一標識表中的每一行數據，並確保其唯一性。主鍵索引是數據庫表的主鍵列上創建的索引。
* 唯一索引（Unique Index）： 確保索引列中的所有值都是唯一的，但允許空值。它可以用於確保某列中的值不重覆，但允許空值存在。
* 普通索引（Normal Index）： 最基本的索引類型，用於加速查詢和數據檢索，但不強制唯一性。
* 組合索引（Composite Index）： 將多個列作為一個索引，用於加速多列的查詢。組合索引的創建順序很重要，可以根據查詢頻率和範圍選擇性來決定列的順序。
* 全文索引（Full-Text Index）： 用於在大文本字段（如文本或文檔）中進行全文搜索的索引類型。這種索引允許在文本中進行關鍵字搜索。

## 索引結構
叢集索引：
* 叢集索引重新組織了資料的物理順序，使資料行按照索引的順序存儲在磁盤上。換句話說，索引的順序決定了資料在磁盤上的存儲方式。
* 在每個表上只能有一個叢集索引。通常情況下，叢集索引是主鍵索引，或者如果沒有顯式指定主鍵，資料庫可能會選擇一個唯一的非空列作為默認的叢集索引。
* 叢集索引的一個重要特性是，它直接決定了數據在磁盤上的排列方式，因此對於按照該索引進行搜索和排序的操作，叢集索引通常可以提供更快的訪問速度。

非叢集索引：
* 非叢集索引並不會重新組織實際資料的物理存儲順序。它們是單獨的結構，保存著指向實際資料行的指針。
* 每個表可以有多個非叢集索引。這些索引提供了其他列的快速查找路徑，但是它們的結構與實際數據在磁盤上的排列無關。
* 對於非叢集索引，資料庫需要首先查找索引，然後再根據索引中的指針找到實際的資料行。因此，使用非叢集索引進行查詢時可能會多一些I/O操作。